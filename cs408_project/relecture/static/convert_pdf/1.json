{"0": "1\n \nIn this video, you\nA\u00fb\nre going to learn about the service provided to applications by TCP \n\n \nthe \nTransmission Control Protocol \n-\n \nwhich is used by over 95% of Internet applications. TCP is almost \nuniversally used because it provides the reliable, end\n-\nto\n-\nend, bi directional byte\n-\nstream service that \nalmost all applications want. \n \n \n", "1": "2\n \nTCP is an example of the transport layer. <click>\n \n \nWhen an application calls TCP, it hands it some bytes that it wants delivered to the other end. \n \nTCP places these bytes into a TCP Segment, and then takes it from there.\n \n \n<click> TCP hands the segment to the IP layer, which encapsulates it in an IP datagram. The IP \naddresses are added.\n \n<click> The IP datagram is handed to the Link Layer, which builds the link frame, adds the Link \naddress \n\n \nfor example, the Ethernet addresses \n\n \nand then sends it onto the wire.\n \n", "2": "When two applications use TCP, they establish a two\n-\nway communication channel between the \nTCP peers at both ends. First TCP establishes a communication channel from A to B <click> Then \nit establishes a channel from B to A <click>.\n \n \nWe call the two way communication a \n\nconnection\n\n. At both ends of the connection, TCP keeps a \nstate machine to keep track of how the connection is doing. We\n\nll see how the state machine works \nin a separate video. \n \n3\n \n", "3": "4\n \nThe TCP connection is established using a 3\n-\nway handshake between hosts A and B. \n \n \nFirst of all <click>, Host A sends a message to B indicating that the TCP layer at A wants to \nestablish a connection with the TCP layer at B. The message is called a SYN message, which is \nshort for synchronize, because A also sends along the base number it will use to identify bytes in \nthe byte stream. If it sends \n\n0\n\n \nthen the numbers will start at zero. If it sends \n\n1,000\n\n \nthen they will \nstart at 1,000. \n \n \n<click> B responds with what we call a SYN + ACK. B signals an ACK because B is \nacknowledging A\n\ns request and agreeing to establish the communication from A to B. The TCP \nlayer at B also sends a SYN back to A to indicate that the TCP layer at B wants to establish a \nconnection with the TCP layer at A. It sends a number too, indicating the starting number for the \nbyte stream. \n \n \n<click> Finally, A responds with an ACK to indicate that it is accepting the request for \ncommunication in the reverse direction. The connection is now setup in both directions. They are \nnow ready to start sending data to each other.\n \n \n \n \n", "4": "5\n \nThe hosts send data to each other as if it is from a continuous stream of bytes.\n \n \n<click to show time> Assume time is increasing from left to right and the stream of bytes next to A \nrepresents the bytes it wants to send to B. The stream of bytes might exist in advance \n\n \nfor \nexample, they are read from an html file describing a static web page. Or it could be a stream being \ngenerated on the fly \n\n \nfor example from a video camera. Either way, TCP sees it as a stream of \nbytes.\n \n \n<click to show arrows> Data from the application on A is delivered to the application at B. The \nTCP layers on A and B work together to make sure the stream of bytes is delivered correctly in \norder to the application at B. \n \n", "5": "6\n \nThe stream of bytes is delivered by TCP segments. <click twice>\n \n \nA puts bytes from the stream into a TCP segment, hands it to the IP layer which delivers it to B. \n<click to move>\n \n \n<click to extract> The TCP layer at B extracts the bytes to recreate the byte stream and delivers \nthem to the application at B. \n \n \nIn practice, the TCP segment may need to be transmitted multiple times, in the case a segment is \ndropped along the way, or if A doesn\n\nt receive an acknowledgment. \n \n \nThe TCP segment can be a small as 1 byte \n\n \nfor example, if you are typing characters in an ssh \nsession, each character is sent one at a time, rather than waiting for the whole segment to fill up.\n \nThis isn\n\nt very efficient when we have lots of data to send; so we can fill the TCP segment all the \nway up to the maximum IP datagram size.\n \n \n", "6": "7\n \n \nWhen A and B have finished sending data to each other, they need to close the connection. We say \nthey \n\nteardown\n\n \nthe connection, which means they tell each other they are closing the connection \nand both ends can clean up the state associated with the state machine. \n \n \n<click> The TCP layer at Host A can close the connection by sending a FIN message, which is \nshort for FINISH. \n \n \n<click> Host B acknowledges that A no longer has data to send and stops looking for new data \nfrom A. This closes down the data stream from A to B. But B might still have new data to send to A \nand is not ready to close down the channel from B to A. So the message from B to A carrying the \nACK can also carry new data from B to A. B can keep sending new data to A as long as it needs to.\n \n \n<click> Sometime later B finishes sending data to A, and now sends its own FIN to tell A they can \nclose the connection.\n \n<click> Host A replies by sending an ACK to acknowledge that the connection is now closed. \nBecause both directions have finished, the connection is now fully closed and the state can be \nsafely removed.\n \n \n \n \n", "7": "Here is a table summarizing the services provided by TCP\n.\n \nThe first three are services TCP provides to the application. As we just saw, <click> it provides a reliable stream of \nbytes between two applications\n.\n \n<click> It uses four mechanisms to make the communication reliable \n\n \nin other words, to make sure the data is \ncorrectly delivered.\n \n1.\nWhen a TCP layer receives data, it sends an acknowledgment back to the sender to let it know the data arrived \ncorrectly.\n \n2.\nChecksums detect corrupted data. The TCP header carries a checksum covering the header and the data inside the \nsegment. The checksum is there to detect if the segment is corrupted along the way, for example by a bit\n-\nerror on the \nwire or by a memory fault inside a router. \n \n3.\nSequence numbers detect missing data. Every segment\n\ns header carries the sequence number \n-\n \nin the stream of bytes \n\n \nof the first byte in the segment. For example, if the two sides agree that the sequence numbers start at 1,000 then the \nfirst segment will have a sequence number of 1,000. If the segment carries 500 bytes of data then the next segment will \ncarry the sequence number 1,500. If a segment gets lost, then the sequence number will be incorrect and the TCP layer \nknows some data is missing. It is possible it will show up later \n\n \nperhaps it took a longer path \n\n \nor it might have gone \nmissing, in which case the sender will need to resend the data.\n \n4.\nFlow\n-\ncontrol prevents overrunning the receiver. If Host A is much faster than Host B then it\n\ns possible for Host A to \noverwhelm Host B by sending data so fast that Host B can\n\nt keep up. TCP prevents this from happening using \nsomething we call flow\n-\ncontrol. In TCP, the receiver keeps telling the sender if it can keep sending; specifically, it tells \nthe sender how much room it has in its buffers to accept new data. If Host B is falling behind, the space drops \n\n \npossibly all the way to zero. When it has more room, it tells A and it can send more data.\n \n \n<click> TCP delivers data to the application in the right sequence; in other words, whatever sequence the data was \ndelivered from the application to TCP at host A, this is the same order in which it is sent from TCP to the application at \nB. If segments arrive out of order, the TCP layer re\n-\nsequences them to the correct order, using the sequence number\n.\n \n<click> Finally, TCP provides a service to the whole network by controlling congestion. TCP tries to divide up the \nnetwork capacity equally among all the TCP connections using the network. The congestion control mechanisms in \nTCP are very complicated and we\n\nll devote the whole of Unit 4 to studying congestion control.\n \n \n8\n \n", "8": "9\n \nThe \nTCP Segment header is much longer and more complicated than, say the IP and Ethernet headers. That is because a TCP connectio\nn i\ns reliable \n\n \nIn order to make the communication reliable, the two ends of the connection need to exchange more information so they know wh\nich\n \nbytes have \narrived, which are missing, and the status of the connection. \n \nHere is a quick summary of the most important fields in the TCP header. You don\n\nt need to remember the layout of the header, but you should learn \nwhat each field does. If you need a reference, I\n\nd recommend Wikipedia or the Kurose and Ross textbook. \n \n<click> The Destination port tells the TCP layer which application the bytes should be delivered to at the other end. When a \nnew\n \nconnection starts \nup, the application tells TCP which service to open a connection with. For example, if TCP is carrying web data, it uses port\n \n80\n, which is the port \nnumber for TCP. You\n\nll learn more about port numbers later, but if you are curious, you can look up the well known port numbers at the IANA \nwebsite. Search for IANA port numbers. You\n\nll find thousands of port numbers defined for different well known services. For example, when we \nopen a connection to an \nssh\n \nserver, we use destination port 22. For \nsmtp\n \n(the simple mail transfer protocol) we use port 23. Using a well known port \nnumber lets Host B identify the application it should establish the connection with\n.\n \n<click> The Source port tells the TCP layer at the other end which port it should use to send data back again. In our example\n, w\nhen Host B replies to \nHost A, it should place Host A\n\ns source port number in the destination port field, so that Host A\n\ns TCP layer can deliver the data to the correct \napplication. When a new connection starts, the initiator of the connection \n\n \nin our case Host A \n\n \ngenerates a unique source port\n \nnumber, so \ndifferentiate the connection from any other connections between Host A and B to the same service. \n \n<click> The Sequence number indicates the position in the byte stream of the first byte in the TCP Data field. For example, i\nf t\nhe Initial Sequence \nnumber is 1,000 and this is the first segment, then the Sequence number is 1,000. If the segment is 500 bytes long, then the \nseq\nuence number in the \nnext segment will be 1,500 and so on\n.\n \n<click> The Acknowledgment sequence number tells the other end which byte we are expecting next. It also says that we have su\ncce\nssfully received \nevery byte up until the one before this byte number. For example, if the Acknowledgment Sequence number is 751, it means we h\nave\n \nreceived every \nbyte up to and including byte 750. Notice that there are sequence numbers for both directions in every segment. This way, TCP\n \npi\nggybacks \nacknowledgments on the data segments traveling in the other direction\n.\n \n<click> The 16 bit checksum is calculated over the entire header and data, and helps the receiver detect corrupt data. For ex\namp\nle, bit errors on the \nwire, or a faulty memory in a router. You\n\nll learn more about error detection and checksums in a later video\n.\n \n<click> The Header Length field tells us how long the TCP header is. <click> The TCP Options fields are, well, optional. They\n \nca\nrry extra, new \nheader fields that were thought of and added after the TCP standard was created. The Header Length field tells us how many op\ntio\nn fields are present. \nUsually there are none\n.\n \nFinally, there are a bunch of Flags used to signal information from one end of the connection to the other. <click> The ACK f\nlag\n \ntells us that the \nAcknowledgement sequence number is valid and we are acknowledging all of the data up until this point. <click> The SYN flag t\nell\ns us that we are \nsignalling\n \na synchronize, which is part of the 3way handshake to set up the connection. <click> And the FIN flag signals the closing of \non\ne direction \nof the connection. <click> Finally, the PSH flag tells the TCP layer at the other end to deliver the data immediately upon ar\nriv\nal, rather than wait for \nmore data. This is useful for short segments carrying time critical data, such as a key stroke. We don\n\nt want the TCP layer to wait to accumulate \nmany keystrokes before delivering them to the application\n.\n \n", "9": "10\n \nA \nTCP connection is uniquely identified by five pieces of information in the TCP and IP headers.\n \nThe IP source and destination addresses uniquely identify the end points, and the IP Protocol ID for TCP tells us the \nconnection is TCP.\n \nThe TCP source and destination ports identify they application processes on the end hosts. Together, at any instant, all \n5 fields uniquely identify the TCP connection Internet\n-\nwide. \n \n \nNow, the unique ID only holds if a few things hold. First, we need to make sure Host A \n\n \nthe initiator of the \nconnection  \n-\n \npicks a unique source port ID. We need to make sure it doesn\n\nt accidentally pick the same source port \nnumber it is already using with another connection to the same service on Host B. Host A uses a simple method to \nminimize the chances: <click> It increments the source port number for every new connection. The field is 16bits, so it \ntakes 64k new connections before the field wraps round.\n \n \nThere is also a very slight danger that if Host A suddenly creates a lot of new connections to Host B it might still wrap \naround and try to create two connections with the same global ID. If this happened, the bytes from one connection \nmight become confused with the bytes from another connection. This could happen, for example, if a TCP segment \nsomehow lived for a long time in the network, stuck inside a router buffer or circulating in a temporary loop. \n \n \n<click> To reduce the chances of confusion, the TCP connections initialize with a random initial sequence number to \nrefer to bytes in the byte stream. While not totally fool proof, it does reduce the chances of confusion. When Host A \ninitiates the connection to B, it includes the initial sequence number if will use in the stream of bytes from A to B. \nWhen B replies and initiates the connection from B to A, it supplies its own initial sequence number for the stream of \nbytes from B to A.\n \n \n", "10": "11\n \n \n \n\n \n<click> The sequence number in a segment from A to B includes the sequence number of the first \nbyte, offset by the initial sequence number.\n \n<click>\n \n \n<click> The acknowledgment sequence number in the segment from B back to A tells us which \nbyte B is expecting next, offset by A\n\ns initial sequence number.\n \n", "11": "12\n \nLet\n\n\n \n \nImagine that Host B on the right offers two services: A Web Server and a Mail Server. \n \n \nWhen the Web client \n\n \nfor example a Chrome browser on Host A \n\n \nwants to request a page from \nthe Web server on B, it sends the data <click> to TCP.\n \nWe\n\nll assume TCP has already established a connection with B, so now it just needs to send the \ndata. It creates a segment and uses destination port 80 to tell B it is requesting the data be sent to \nthe web server.\n \nHost A uses a locally generated source port number for B to use when sending data and \nacknowledgments back again.\n \n \n<click> As usual, the TCP segment is encapsulated into an IP datagram and sent to B. The IP + \nTCP headers carry the unique ID of the TCP connection.\n \n<click> When the IP datagram arrives at B, the TCP segment is removed. The TCP layer sees that \nthe segment is for port 80 and sends the data to the web server <click>\n \n \n", "12": "13\n \nYou\n\nll learn about other features of TCP in upcoming videos.\n \n \nYou\n\nll learn about window\n-\nbased flow control and to stop us from overwhelming the receiver.\n \nYou\n\nll learn about retransmissions and timeouts and different methods to accomplish it.\n \nAnd you\n\nll learn about Congestion Control in Unit 4.\n \n \n", "13": "In summary, \nTCP provides in\n-\norder, reliable delivery of a stream of bytes between application processes.\n \n \n \n14\n \n", "14": "15\n \n"}